{% if run %}
{% set organized = organize_steps_with_branches(steps) %}
{% set main_steps = organized.main %}
{% set branches_by_parent = organized.branches_by_parent %}

<style>
.tree-controls {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.tree-controls button {
    padding: 0.5rem 1rem;
    font-size: 0.8125rem;
    font-weight: 500;
    border-radius: 9999px;
    border: none;
    background: #f3f4f6;
    color: #374151;
    cursor: pointer;
    transition: all 0.15s;
}

.tree-controls button:hover {
    background: #e5e7eb;
}

.tree-controls button.active {
    background: #161b22;
    color: white;
}

.tree-container {
    background: #fafbfc;
    border: 1px solid #e1e4e8;
    border-radius: 12px;
    overflow: auto;
    padding: 2rem;
}

#tree-svg {
    display: block;
}

/* CircleCI-style nodes */
#tree-svg .node-rect {
    rx: 8;
    ry: 8;
    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.05));
}

#tree-svg .node-rect.completed { fill: #2da44e; }
#tree-svg .node-rect.running { fill: #2f81f7; }
#tree-svg .node-rect.failed { fill: #cf222e; }
#tree-svg .node-rect.skipped {
    fill: white;
    stroke: #d0d7de;
    stroke-width: 1;
    stroke-dasharray: 4 2;
}
#tree-svg .node-rect.pending {
    fill: white;
    stroke: #d0d7de;
    stroke-width: 1;
}
#tree-svg .node-rect.router {
    stroke: #8250df;
    stroke-width: 2;
}

#tree-svg .node-group { cursor: pointer; }
#tree-svg .node-group:hover .node-rect { filter: brightness(0.95) drop-shadow(0 2px 4px rgba(0,0,0,0.1)); }

#tree-svg .node-text {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 12px;
    font-weight: 500;
}
#tree-svg .node-text.light { fill: white; }
#tree-svg .node-text.dark { fill: #24292f; }
#tree-svg .node-text.muted { fill: #656d76; }

#tree-svg .node-duration {
    font-family: ui-monospace, SFMono-Regular, 'SF Mono', monospace;
    font-size: 10px;
    opacity: 0.75;
}

#tree-svg .link {
    fill: none;
    stroke: #d0d7de;
    stroke-width: 2;
}
#tree-svg .link.active { stroke: #2da44e; }

#tree-svg .branch-pill {
    rx: 10;
    ry: 10;
}
#tree-svg .branch-pill.active { fill: #ddf4ff; }
#tree-svg .branch-pill.inactive { fill: #f6f8fa; }

#tree-svg .branch-text {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.3px;
}
#tree-svg .branch-text.active { fill: #0969da; }
#tree-svg .branch-text.inactive { fill: #656d76; }
</style>

<div data-run-status="{{ run.status }}">
    <h2 class="text-lg font-semibold text-gray-900 mb-3">Pipeline Steps</h2>

    <div class="tree-controls">
        <button id="btn-h" onclick="setLayout('horizontal')">Horizontal</button>
        <button id="btn-v" class="active" onclick="setLayout('vertical')">Vertical</button>
    </div>

    <div class="tree-container">
        <svg id="tree-svg"></svg>
    </div>

    <script>
    (function() {
        const mainSteps = {{ main_steps | tojson }};
        const branchesByParent = {{ branches_by_parent | tojson }};
        const runId = "{{ run.id }}";
        const dbPath = "{{ db_path }}";

        const NODE_H = 36;
        const NODE_PAD = 16;
        const H_SPACING = 60;
        const V_SPACING = 60;
        const BRANCH_SPACING = 40;

        let layout = localStorage.getItem('pipelineLayout') || 'vertical';

        function textWidth(text) {
            return text.length * 7.5 + NODE_PAD * 2 + 40;
        }

        function nodeColors(status) {
            const light = ['completed', 'running', 'failed'];
            return {
                rectClass: status,
                textClass: light.includes(status) ? 'light' : (status === 'skipped' ? 'muted' : 'dark')
            };
        }

        function setLayout(l) {
            layout = l;
            localStorage.setItem('pipelineLayout', l);
            document.getElementById('btn-h').classList.toggle('active', l === 'horizontal');
            document.getElementById('btn-v').classList.toggle('active', l === 'vertical');
            render();
        }

        function render() {
            const svg = document.getElementById('tree-svg');
            svg.innerHTML = '';

            const isH = layout === 'horizontal';
            const nodes = [];
            const links = [];
            const processedSteps = new Set();

            // First pass: collect all data and calculate sizes
            let cursor = 40;
            const mainCenter = isH ? 200 : 250;

            for (let i = 0; i < mainSteps.length; i++) {
                const step = mainSteps[i];
                if (processedSteps.has(step.name)) continue;
                processedSteps.add(step.name);

                const w = textWidth(step.name);
                const isRouter = step.name.startsWith('route_');
                const hasBranches = branchesByParent[step.name];

                let x, y;
                if (isH) {
                    x = cursor;
                    y = mainCenter - NODE_H / 2;
                } else {
                    x = mainCenter - w / 2;
                    y = cursor;
                }

                const node = { ...step, x, y, w, h: NODE_H, isRouter };
                nodes.push(node);

                // Link to previous
                if (nodes.length > 1) {
                    const prev = nodes[nodes.length - 2];
                    if (!prev._hasBranches) {
                        links.push({ from: prev, to: node, active: prev.status === 'completed' });
                    }
                }

                if (hasBranches) {
                    node._hasBranches = true;
                    const branches = branchesByParent[step.name];
                    const branchNames = Object.keys(branches);
                    const branchNodes = [];

                    // Calculate branch layout
                    let branchCursor = isH ? y + NODE_H + V_SPACING : x + w + H_SPACING;

                    branchNames.forEach((bname, bi) => {
                        const bsteps = branches[bname];
                        const isActive = bsteps[0] && bsteps[0].status !== 'skipped';

                        // Branch label
                        const labelW = bname.length * 6.5 + 16;
                        let lx, ly;
                        if (isH) {
                            lx = x + w / 2 + (bi - (branchNames.length - 1) / 2) * (NODE_H + BRANCH_SPACING * 3) - labelW / 2;
                            ly = branchCursor - 28;
                        } else {
                            lx = branchCursor - labelW / 2;
                            ly = y + NODE_H / 2 - 10;
                        }
                        nodes.push({ type: 'label', name: bname, x: lx, y: ly, w: labelW, active: isActive });

                        // Branch steps
                        let stepCursor = isH ? branchCursor : branchCursor;
                        let lastBranchNode = null;

                        bsteps.forEach((bstep, si) => {
                            const bw = textWidth(bstep.name);
                            const isBRouter = bstep.name.startsWith('route_');
                            const hasNested = branchesByParent[bstep.name];

                            let bx, by;
                            if (isH) {
                                bx = x + w / 2 + (bi - (branchNames.length - 1) / 2) * (NODE_H + BRANCH_SPACING * 3) - bw / 2;
                                by = stepCursor;
                            } else {
                                bx = stepCursor - bw / 2;
                                by = y + NODE_H + V_SPACING / 2 + bi * (NODE_H + BRANCH_SPACING);
                            }

                            const bnode = { ...bstep, x: bx, y: by, w: bw, h: NODE_H, isRouter: isBRouter, branchName: bname };
                            nodes.push(bnode);

                            // Link from router or previous branch step
                            if (si === 0) {
                                links.push({ from: node, to: bnode, active: node.status === 'completed' && isActive });
                            } else if (lastBranchNode) {
                                links.push({ from: lastBranchNode, to: bnode, active: lastBranchNode.status === 'completed' });
                            }

                            lastBranchNode = bnode;

                            // Nested branches
                            if (hasNested) {
                                const nested = branchesByParent[bstep.name];
                                const nestedNames = Object.keys(nested);
                                let nestedCursor = isH ? by + NODE_H + V_SPACING : bx + bw + H_SPACING;

                                nestedNames.forEach((nname, ni) => {
                                    const nsteps = nested[nname];
                                    const nActive = nsteps[0] && nsteps[0].status !== 'skipped';

                                    // Nested label
                                    const nlabelW = nname.length * 6.5 + 16;
                                    let nlx, nly;
                                    if (isH) {
                                        nlx = bx + bw / 2 + (ni - (nestedNames.length - 1) / 2) * (NODE_H + BRANCH_SPACING * 2) - nlabelW / 2;
                                        nly = nestedCursor - 24;
                                    } else {
                                        nlx = nestedCursor - nlabelW / 2;
                                        nly = by + NODE_H / 2 - 10;
                                    }
                                    nodes.push({ type: 'label', name: nname, x: nlx, y: nly, w: nlabelW, active: nActive });

                                    // Nested steps
                                    nsteps.forEach(nstep => {
                                        const nw = textWidth(nstep.name);
                                        let nx, ny;
                                        if (isH) {
                                            nx = bx + bw / 2 + (ni - (nestedNames.length - 1) / 2) * (NODE_H + BRANCH_SPACING * 2) - nw / 2;
                                            ny = nestedCursor;
                                        } else {
                                            nx = nestedCursor - nw / 2;
                                            ny = by + NODE_H + BRANCH_SPACING + ni * (NODE_H + BRANCH_SPACING / 2);
                                        }

                                        const nnode = { ...nstep, x: nx, y: ny, w: nw, h: NODE_H, branchName: nname };
                                        nodes.push(nnode);
                                        links.push({ from: bnode, to: nnode, active: bnode.status === 'completed' && nActive });
                                        branchNodes.push(nnode);

                                        if (isH) {
                                            nestedCursor = Math.max(nestedCursor, ny + NODE_H + V_SPACING);
                                        }
                                    });

                                    if (isH) {
                                        // Already updated
                                    } else {
                                        nestedCursor += textWidth(nsteps[0]?.name || '') + BRANCH_SPACING;
                                    }
                                });

                                if (isH) {
                                    stepCursor = nestedCursor;
                                }
                            } else {
                                branchNodes.push(bnode);
                                if (isH) {
                                    stepCursor += NODE_H + V_SPACING / 2;
                                }
                            }
                        });

                        if (isH) {
                            branchCursor = Math.max(branchCursor, stepCursor);
                        } else {
                            branchCursor += textWidth(bsteps[0]?.name || '') + BRANCH_SPACING * 1.5;
                        }
                    });

                    // Find next main step (save_text) and connect all branches to it
                    const nextIdx = i + 1;
                    if (nextIdx < mainSteps.length) {
                        const nextStep = mainSteps[nextIdx];
                        processedSteps.add(nextStep.name);
                        const nw = textWidth(nextStep.name);

                        let nx, ny;
                        if (isH) {
                            cursor += w + H_SPACING;
                            nx = cursor;
                            ny = mainCenter - NODE_H / 2;
                        } else {
                            // Position below all branches
                            let maxY = y;
                            branchNodes.forEach(bn => {
                                maxY = Math.max(maxY, bn.y + bn.h);
                            });
                            cursor = maxY + V_SPACING;
                            nx = mainCenter - nw / 2;
                            ny = cursor;
                        }

                        const nextNode = { ...nextStep, x: nx, y: ny, w: nw, h: NODE_H, isRouter: nextStep.name.startsWith('route_') };
                        nodes.push(nextNode);

                        // Connect all branch ends to next node
                        branchNodes.forEach(bn => {
                            links.push({ from: bn, to: nextNode, active: bn.status === 'completed' });
                        });

                        if (isH) {
                            cursor += nw + H_SPACING;
                        } else {
                            cursor += NODE_H + V_SPACING;
                        }
                    }
                } else {
                    if (isH) {
                        cursor += w + H_SPACING;
                    } else {
                        cursor += NODE_H + V_SPACING;
                    }
                }
            }

            // Calculate SVG size
            let maxX = 0, maxY = 0;
            nodes.forEach(n => {
                if (n.type !== 'label') {
                    maxX = Math.max(maxX, n.x + n.w);
                    maxY = Math.max(maxY, n.y + n.h);
                } else {
                    maxX = Math.max(maxX, n.x + n.w);
                    maxY = Math.max(maxY, n.y + 20);
                }
            });

            svg.setAttribute('width', maxX + 60);
            svg.setAttribute('height', maxY + 60);

            // Draw links
            links.forEach(link => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const f = link.from;
                const t = link.to;

                let x1 = f.x + f.w / 2;
                let y1 = f.y + f.h;
                let x2 = t.x + t.w / 2;
                let y2 = t.y;

                // Bezier curve
                const midY = (y1 + y2) / 2;
                const d = `M${x1},${y1} C${x1},${midY} ${x2},${midY} ${x2},${y2}`;

                path.setAttribute('d', d);
                path.setAttribute('class', 'link' + (link.active ? ' active' : ''));
                svg.appendChild(path);
            });

            // Draw nodes
            nodes.forEach(node => {
                if (node.type === 'label') {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                    const pill = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    pill.setAttribute('x', node.x);
                    pill.setAttribute('y', node.y);
                    pill.setAttribute('width', node.w);
                    pill.setAttribute('height', 18);
                    pill.setAttribute('class', 'branch-pill ' + (node.active ? 'active' : 'inactive'));
                    g.appendChild(pill);

                    const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    txt.setAttribute('x', node.x + node.w / 2);
                    txt.setAttribute('y', node.y + 13);
                    txt.setAttribute('text-anchor', 'middle');
                    txt.setAttribute('class', 'branch-text ' + (node.active ? 'active' : 'inactive'));
                    txt.textContent = node.name.toUpperCase();
                    g.appendChild(txt);

                    svg.appendChild(g);
                } else {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'node-group');
                    g.onclick = () => openStepModal(runId, node.step_index, dbPath);

                    const colors = nodeColors(node.status);

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', node.x);
                    rect.setAttribute('y', node.y);
                    rect.setAttribute('width', node.w);
                    rect.setAttribute('height', node.h);
                    rect.setAttribute('class', 'node-rect ' + colors.rectClass + (node.isRouter ? ' router' : ''));
                    g.appendChild(rect);

                    // Icon
                    const iconPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    iconPath.setAttribute('transform', `translate(${node.x + 10}, ${node.y + 10}) scale(0.67)`);
                    iconPath.setAttribute('fill', 'none');
                    iconPath.setAttribute('stroke', colors.textClass === 'light' ? 'white' : '#656d76');
                    iconPath.setAttribute('stroke-width', '2');
                    iconPath.setAttribute('stroke-linecap', 'round');

                    const icons = {
                        completed: 'M5 13l4 4L19 7',
                        running: 'M12 6v6l4 2',
                        failed: 'M6 18L18 6M6 6l12 12',
                        skipped: 'M13 5l7 7-7 7M5 5l7 7-7 7',
                        pending: 'M12 8v4m0 4h.01'
                    };
                    iconPath.setAttribute('d', icons[node.status] || icons.pending);
                    g.appendChild(iconPath);

                    // Name
                    const nameText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    nameText.setAttribute('x', node.x + 32);
                    nameText.setAttribute('y', node.y + node.h / 2 + 4);
                    nameText.setAttribute('class', 'node-text ' + colors.textClass);
                    nameText.textContent = node.name;
                    g.appendChild(nameText);

                    // Duration
                    if (node.duration_s != null) {
                        const dur = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        dur.setAttribute('x', node.x + node.w - 8);
                        dur.setAttribute('y', node.y + node.h / 2 + 4);
                        dur.setAttribute('text-anchor', 'end');
                        dur.setAttribute('class', 'node-duration ' + colors.textClass);
                        const d = node.duration_s;
                        dur.textContent = d < 1 ? Math.round(d * 1000) + 'ms' : d.toFixed(2) + 's';
                        g.appendChild(dur);
                    }

                    svg.appendChild(g);
                }
            });
        }

        // Initial
        document.getElementById('btn-h').classList.toggle('active', layout === 'horizontal');
        document.getElementById('btn-v').classList.toggle('active', layout === 'vertical');
        render();

        window.setLayout = setLayout;
    })();
    </script>

    <!-- Step list -->
    <div class="mt-4 border-t pt-4">
        <div class="text-xs font-medium text-gray-500 uppercase tracking-wide mb-2">All Steps</div>
        <div class="space-y-0.5">
        {% for step in steps %}
        {% set is_branch = step.branch is not none %}
        <div class="flex items-center gap-2 px-3 py-2 rounded-lg hover:bg-gray-100 cursor-pointer {% if is_branch %}ml-4{% endif %}"
             onclick="openStepModal('{{ run.id }}', {{ step.step_index }}, '{{ db_path }}')">
            <span class="w-2 h-2 rounded-full flex-shrink-0
                {% if step.status == 'completed' %}bg-green-500
                {% elif step.status == 'running' %}bg-blue-500
                {% elif step.status == 'failed' %}bg-red-500
                {% elif step.status == 'skipped' %}bg-gray-300
                {% else %}bg-gray-400{% endif %}"></span>
            {% if step.branch %}
            <span class="text-xs px-1.5 py-0.5 rounded bg-blue-100 text-blue-700 font-medium">{{ step.branch }}</span>
            {% endif %}
            <span class="text-sm {% if step.status == 'skipped' %}text-gray-400{% else %}text-gray-700{% endif %} flex-1">{{ step.name }}</span>
            <span class="text-xs text-gray-400 font-mono">{{ step.duration_s | format_duration if step.duration_s else '-' }}</span>
        </div>
        {% endfor %}
        </div>
    </div>
</div>
{% else %}
<p class="text-gray-500">No step information available.</p>
{% endif %}

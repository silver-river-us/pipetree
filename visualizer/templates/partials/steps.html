{% if run %}
<style>
.tree-controls {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 0;
}

.tree-controls button {
    padding: 0.5rem 1rem;
    font-size: 0.8125rem;
    font-weight: 500;
    border-radius: 0;
    border: 1px solid #d0d7de;
    background: white;
    color: #24292f;
    cursor: pointer;
    transition: all 0.15s;
}

.tree-controls button:hover {
    background: #f6f8fa;
}

.tree-controls button.active {
    background: #0969da;
    color: white;
    border-color: #0969da;
}

.tree-container {
    background: white;
    border: 1px solid #d0d7de;
    border-radius: 0;
    overflow: auto;
    padding: 24px;
}

#tree-svg {
    display: block;
}

/* CircleCI-style nodes - white background, gray border */
#tree-svg .node-rect {
    rx: 0;
    ry: 0;
    fill: white;
    stroke: #d0d7de;
    stroke-width: 1;
}


#tree-svg .node-group { cursor: pointer; }
#tree-svg .node-group:hover .node-rect { fill: #f6f8fa; }

#tree-svg .node-text {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 13px;
    font-weight: 500;
    fill: #24292f;
}

#tree-svg .node-duration {
    font-family: ui-monospace, monospace;
    font-size: 11px;
    fill: #57606a;
}

#tree-svg .link {
    fill: none;
    stroke: #d0d7de;
    stroke-width: 2;
}
#tree-svg .link.active { stroke: #1a7f37; }
#tree-svg .link.router { stroke: #8250df; }

/* Spinner animation for running state */
@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
#tree-svg .spinner {
    animation: spin 1s linear infinite;
    transform-origin: center;
}

#tree-svg .branch-text {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    fill: #57606a;
}
#tree-svg .branch-text.active { fill: #0969da; }
</style>

<div data-run-status="{{ run.status }}">
    {% include "partials/steps_data.html" %}
    <div class="flex items-center justify-between mb-2">
        <h2 class="text-lg font-semibold text-gray-900">Pipeline Steps</h2>
        <div class="tree-controls">
            <button id="btn-h" onclick="setLayout('horizontal')">Horizontal</button>
            <button id="btn-v" class="active" onclick="setLayout('vertical')">Vertical</button>
        </div>
    </div>

    <div class="tree-container">
        <svg id="tree-svg"></svg>
    </div>

    <script>
    (function() {
        let currentData = null;
        let currentRunId = "";
        let currentDbPath = "";

        const NODE_H = 36;
        const H_GAP = 24;
        const V_GAP = 48;
        const BRANCH_GAP = 60;

        let layout = localStorage.getItem('pipelineLayout') || 'vertical';

        const MAX_NODE_WIDTH = 220;
        const MIN_NODE_WIDTH = 100;

        function textWidth(name, durationS, isRouter) {
            // Calculate width based on content
            const nameWidth = name.length * 7.5;
            const durationWidth = durationS != null && !isRouter ? 50 : 0; // space for duration
            const padding = 50; // icon + margins
            const calculated = nameWidth + durationWidth + padding;
            return Math.min(MAX_NODE_WIDTH, Math.max(MIN_NODE_WIDTH, calculated));
        }

        function truncateName(name, maxChars) {
            if (name.length <= maxChars) return name;
            return name.substring(0, maxChars - 1) + 'â€¦';
        }

        function setLayout(l) {
            layout = l;
            localStorage.setItem('pipelineLayout', l);
            document.getElementById('btn-h').classList.toggle('active', l === 'horizontal');
            document.getElementById('btn-v').classList.toggle('active', l === 'vertical');
            render();
        }

        function readStepsData() {
            const el = document.getElementById('steps-data');
            if (!el) return null;
            return {
                mainSteps: JSON.parse(el.dataset.mainSteps || '[]'),
                branchesByParent: JSON.parse(el.dataset.branchesByParent || '{}'),
                runId: el.dataset.runId || '',
                dbPath: el.dataset.dbPath || ''
            };
        }

        function setData() {
            currentData = readStepsData();
            currentRunId = currentData ? currentData.runId : "";
            currentDbPath = currentData ? currentData.dbPath : "";
        }

        function render() {
            if (!currentData) return;
            const svg = document.getElementById('tree-svg');
            const container = svg.closest('.tree-container');
            const prevScrollLeft = container ? container.scrollLeft : 0;
            const prevScrollTop = container ? container.scrollTop : 0;
            svg.innerHTML = '';

            const isH = layout === 'horizontal';
            const nodes = [];
            const links = [];
            const mainSteps = currentData.mainSteps;
            const branchesByParent = currentData.branchesByParent;

            // Find which main step has branches and which is the final step
            let routerIndex = -1;
            let finalStepIndex = mainSteps.length - 1;

            mainSteps.forEach((step, i) => {
                if (branchesByParent[step.name]) {
                    routerIndex = i;
                }
            });

            // Layout: pre-router steps, then router, then branches, then final step at bottom
            const margin = 40;
            let y = margin;
            let maxWidth = 0;

            // Pre-router steps (before branches)
            const preRouterSteps = mainSteps.slice(0, routerIndex + 1);
            const postRouterSteps = mainSteps.slice(routerIndex + 1);

            const stepRan = (step) => step && (step.status === 'completed' || step.status === 'running' || step.status === 'failed');

            function branchHasActivity(steps, branchesMap) {
                if (!Array.isArray(steps) || steps.length === 0) return false;
                for (const step of steps) {
                    if (stepRan(step)) return true;
                    const nested = branchesMap[step.name];
                    if (nested) {
                        for (const nestedSteps of Object.values(nested)) {
                            if (branchHasActivity(nestedSteps, branchesMap)) return true;
                        }
                    }
                }
                return false;
            }

            if (isH) {
                // Horizontal: main flow left-to-right, branches extend right
                let x = margin;
                const centerY = margin + 100; // Vertical center for main flow

                // Pre-router steps in a horizontal row
                preRouterSteps.forEach((step, i) => {
                    const isRouter = step.name.startsWith('route_');
                    const w = textWidth(step.name, step.duration_s, isRouter);
                    nodes.push({ ...step, x, y: centerY - NODE_H/2, w, h: NODE_H, isRouter });
                    if (i > 0) {
                        const prev = nodes[nodes.length - 2];
                        links.push({ type: 'h', x1: prev.x + prev.w, y1: centerY, x2: x, y2: centerY, active: prev.status === 'completed' });
                    }
                    x += w + H_GAP;
                });

                // Router branches - each branch extends to the right on its own row
                const router = nodes[nodes.length - 1];
                const branches = branchesByParent[router.name] || {};
                const branchNames = Object.keys(branches);

                const branchStartX = router.x + router.w + H_GAP * 2;
                const branchEndPoints = [];
                let maxX = branchStartX;

                // Stack branches vertically, each extending horizontally
                branchNames.forEach((bname, bi) => {
                    const bsteps = branches[bname];
                    const branchRan = branchHasActivity(bsteps, branchesByParent);
                    const branchY = centerY + (bi - (branchNames.length - 1) / 2) * (NODE_H + BRANCH_GAP);

                    // Branch label above the first step
                    nodes.push({ type: 'label', name: bname, x: branchStartX, y: branchY - NODE_H/2 - 20, active: branchRan });

                    let bx = branchStartX;

                    bsteps.forEach((bstep, si) => {
                        const isRouter = bstep.name.startsWith('route_');
                        const bw = textWidth(bstep.name, bstep.duration_s, isRouter);
                        const bnode = { ...bstep, x: bx, y: branchY - NODE_H/2, w: bw, h: NODE_H, isRouter };
                        nodes.push(bnode);

                        // Link from router to first step - only active if router completed AND branch ran
                        if (si === 0) {
                            const isRouterLink = router.isRouter && branchRan;
                            links.push({ type: 'h', x1: router.x + router.w, y1: centerY, x2: bx, y2: branchY, active: stepRan(router) && branchRan, isRouter: isRouterLink });
                        }

                        // Handle nested branches (extend further right)
                        const nested = branchesByParent[bstep.name];
                        if (nested) {
                            const nestedNames = Object.keys(nested);
                            const nestedStartX = bx + bw + H_GAP * 2;

                            nestedNames.forEach((nname, ni) => {
                                const nsteps = nested[nname];
                                const nestedRan = branchHasActivity(nsteps, branchesByParent);
                                const nestedY = branchY + (ni - (nestedNames.length - 1) / 2) * (NODE_H + 24);

                                nodes.push({ type: 'label', name: nname, x: nestedStartX, y: nestedY - NODE_H/2 - 20, active: nestedRan });

                                let nx = nestedStartX;
                                nsteps.forEach(nstep => {
                                    const nw = textWidth(nstep.name, nstep.duration_s, false);
                                    const nnode = { ...nstep, x: nx, y: nestedY - NODE_H/2, w: nw, h: NODE_H };
                                    nodes.push(nnode);
                                    // Purple only if router completed AND nested branch ran
                                    const isRouterLink = bnode.isRouter && nestedRan;
                                    links.push({ type: 'h', x1: bx + bw, y1: branchY, x2: nx, y2: nestedY, active: bnode.status === 'completed' && nestedRan, isRouter: isRouterLink });
                                    branchEndPoints.push({ x: nx + nw, y: nestedY, center: nestedY, active: nstep.status === 'completed' });
                                    maxX = Math.max(maxX, nx + nw);
                                    nx += nw + H_GAP;
                                });
                            });
                        } else {
                            // Use center of node for proper visual alignment
                            branchEndPoints.push({ x: bx + bw, y: branchY, center: branchY, active: bstep.status === 'completed' });
                            maxX = Math.max(maxX, bx + bw);
                        }

                        bx += bw + H_GAP;
                    });
                });

                // Convergence point - all branches meet at right side
                const convergeX = maxX + H_GAP * 2;

                // Calculate vertical center based on node centers (not tops)
                const minCenter = Math.min(...branchEndPoints.map(p => p.center));
                const maxCenter = Math.max(...branchEndPoints.map(p => p.center));
                const convergeY = (minCenter + maxCenter) / 2;

                // Draw convergence lines (horizontal to convergence X, then vertical to center)
                branchEndPoints.forEach(pt => {
                    links.push({ type: 'L', x1: pt.x, y1: pt.y, x2: convergeX, y2: pt.y, x3: convergeX, y3: convergeY, active: pt.active });
                });

                // Final step after convergence - centered vertically
                if (postRouterSteps.length > 0) {
                    const finalStep = postRouterSteps[0];
                    const fw = textWidth(finalStep.name, finalStep.duration_s, false);
                    const finalX = convergeX + H_GAP;
                    const finalRan = finalStep.status === 'completed' || finalStep.status === 'running';
                    nodes.push({ ...finalStep, x: finalX, y: convergeY - NODE_H/2, w: fw, h: NODE_H });
                    links.push({ type: 'h', x1: convergeX, y1: convergeY, x2: finalX, y2: convergeY, active: finalRan });
                    maxX = finalX + fw;
                }

                maxWidth = maxX + margin;
                y = centerY + (branchNames.length / 2) * (NODE_H + BRANCH_GAP) + NODE_H + margin;

            } else {
                // Vertical layout - everything flows top to bottom

                // First, calculate the total width needed for all branches
                const router_step = preRouterSteps[preRouterSteps.length - 1];
                const branches = branchesByParent[router_step?.name] || {};
                const branchNames = Object.keys(branches);

                // Calculate max nested width
                let maxNestedWidth = 0;
                branchNames.forEach(bname => {
                    const bsteps = branches[bname];
                    bsteps.forEach(bstep => {
                        const nested = branchesByParent[bstep.name];
                        if (nested) {
                            const nestedNames = Object.keys(nested);
                            maxNestedWidth = Math.max(maxNestedWidth, (nestedNames.length - 1) * 240);
                        }
                    });
                });

                const branchSpacing = Math.max(200, maxNestedWidth + 50);
                const totalBranchWidth = (branchNames.length - 1) * branchSpacing;

                // Center X should accommodate the widest part
                const centerX = margin + Math.max(150, totalBranchWidth / 2 + 120);

                // Pre-router steps vertically
                preRouterSteps.forEach((step, i) => {
                    const isRouter = step.name.startsWith('route_');
                    const w = textWidth(step.name, step.duration_s, isRouter);
                    nodes.push({ ...step, x: centerX - w/2, y, w, h: NODE_H, isRouter });
                    if (i > 0) {
                        const prev = nodes[nodes.length - 2];
                        links.push({ type: 'v', x1: centerX, y1: prev.y + NODE_H, x2: centerX, y2: y, active: prev.status === 'completed' });
                    }
                    y += NODE_H + V_GAP;
                    maxWidth = Math.max(maxWidth, centerX + w/2 + margin);
                });

                // Router and branches - spread horizontally, then each branch goes down
                const router = nodes[nodes.length - 1];

                const branchEndPoints = [];
                let maxBranchY = y;

                // Calculate branch positions
                const branchStartX = centerX - totalBranchWidth / 2;

                branchNames.forEach((bname, bi) => {
                    const bsteps = branches[bname];
                    const branchRan = branchHasActivity(bsteps, branchesByParent);
                    const branchX = branchStartX + bi * branchSpacing;

                    // Branch label
                    nodes.push({ type: 'label', name: bname, x: branchX, y: y - 22, active: branchRan, align: 'middle' });

                    let by = y;

                    bsteps.forEach((bstep, si) => {
                        const isRouter = bstep.name.startsWith('route_');
                        const bw = textWidth(bstep.name, bstep.duration_s, isRouter);
                        const bnode = { ...bstep, x: branchX - bw/2, y: by, w: bw, h: NODE_H, isRouter };
                        nodes.push(bnode);

                        if (si === 0) {
                            // Link from router down to branch - only active if router completed AND branch ran
                            const isRouterLink = router.isRouter && branchRan;
                            links.push({ type: 'v', x1: centerX, y1: router.y + NODE_H, x2: branchX, y2: by, active: stepRan(router) && branchRan, isRouter: isRouterLink });
                        }

                        // Handle nested branches
                        const nested = branchesByParent[bstep.name];
                        if (nested) {
                            const nestedNames = Object.keys(nested);
                            const nestedSpacing = 240; // Enough space for node width + gap
                            const nestedTotalWidth = (nestedNames.length - 1) * nestedSpacing;
                            const nestedStartX = branchX - nestedTotalWidth / 2;
                            let nestedY = by + NODE_H + V_GAP;

                            nestedNames.forEach((nname, ni) => {
                                const nsteps = nested[nname];
                                const nestedRan = branchHasActivity(nsteps, branchesByParent);
                                const nestedX = nestedStartX + ni * nestedSpacing;

                                nodes.push({ type: 'label', name: nname, x: nestedX, y: nestedY - 22, active: nestedRan, align: 'middle' });

                                let ny = nestedY;
                                nsteps.forEach(nstep => {
                                    const nw = textWidth(nstep.name, nstep.duration_s, false);
                                    const nnode = { ...nstep, x: nestedX - nw/2, y: ny, w: nw, h: NODE_H };
                                    nodes.push(nnode);
                                    // Purple only if router completed AND nested branch actually ran
                                    const isRouterLink = bnode.isRouter && nestedRan;
                                    links.push({ type: 'v', x1: branchX, y1: bnode.y + NODE_H, x2: nestedX, y2: ny, active: bnode.status === 'completed' && nestedRan, isRouter: isRouterLink });
                                    branchEndPoints.push({ x: nestedX, y: ny + NODE_H, active: nstep.status === 'completed' });
                                    maxBranchY = Math.max(maxBranchY, ny + NODE_H);
                                    maxWidth = Math.max(maxWidth, nestedX + nw/2 + margin);
                                    ny += NODE_H + V_GAP;
                                });
                            });
                            by = nestedY + NODE_H;
                        } else {
                            branchEndPoints.push({ x: branchX, y: by + NODE_H, active: bstep.status === 'completed' });
                            maxBranchY = Math.max(maxBranchY, by + NODE_H);
                        }

                        maxWidth = Math.max(maxWidth, branchX + bw/2 + margin);
                        by += NODE_H + V_GAP;
                    });
                });

                // Convergence and final step
                const convergeY = maxBranchY + V_GAP / 2;

                // Convergence lines (all branches down to converge point, then to center)
                branchEndPoints.forEach(pt => {
                    links.push({ type: 'L', x1: pt.x, y1: pt.y, x2: pt.x, y2: convergeY, x3: centerX, y3: convergeY, active: pt.active });
                });

                // Final step below convergence
                if (postRouterSteps.length > 0) {
                    const finalStep = postRouterSteps[0];
                    const fw = textWidth(finalStep.name, finalStep.duration_s, false);
                    const finalY = convergeY + V_GAP / 2;
                    const finalRan = finalStep.status === 'completed' || finalStep.status === 'running';
                    nodes.push({ ...finalStep, x: centerX - fw/2, y: finalY, w: fw, h: NODE_H });
                    links.push({ type: 'v', x1: centerX, y1: convergeY, x2: centerX, y2: finalY, active: finalRan });
                    y = finalY + NODE_H + margin;
                } else {
                    y = convergeY + margin;
                }

                maxWidth = Math.max(maxWidth, centerX + margin);
            }

            // Set SVG size - find bounds of all nodes
            let minX = margin;
            let maxX = maxWidth;
            let svgH = y + margin;
            nodes.forEach(n => {
                if (n.type !== 'label' && n.x != null) {
                    minX = Math.min(minX, n.x);
                    maxX = Math.max(maxX, n.x + (n.w || 0));
                    svgH = Math.max(svgH, (n.y || 0) + (n.h || 0) + margin);
                }
            });

            // If any nodes are to the left of margin, shift everything right
            if (minX < margin) {
                const shiftX = margin - minX + 20;
                nodes.forEach(n => {
                    if (n.x != null) n.x += shiftX;
                });
                links.forEach(l => {
                    if (l.x1 != null) l.x1 += shiftX;
                    if (l.x2 != null) l.x2 += shiftX;
                    if (l.x3 != null) l.x3 += shiftX;
                });
                maxX += shiftX;
            }

            const svgW = maxX + margin;
            svg.setAttribute('width', svgW);
            svg.setAttribute('height', svgH);

            // Draw links first (inactive first so active paths sit on top)
            const sortedLinks = [...links].sort((a, b) => {
                const rank = (l) => (l.isRouter ? 1 : (l.active ? 2 : 0));
                return rank(a) - rank(b);
            });
            sortedLinks.forEach(link => {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let d;

                if (link.type === 'h') {
                    // Straight horizontal (with possible vertical offset)
                    if (link.y1 === link.y2) {
                        d = `M${link.x1},${link.y1} L${link.x2},${link.y2}`;
                    } else {
                        // L-shape: horizontal then vertical
                        const midX = (link.x1 + link.x2) / 2;
                        d = `M${link.x1},${link.y1} L${midX},${link.y1} L${midX},${link.y2} L${link.x2},${link.y2}`;
                    }
                } else if (link.type === 'v') {
                    // Straight vertical (with possible horizontal offset)
                    if (link.x1 === link.x2) {
                        d = `M${link.x1},${link.y1} L${link.x2},${link.y2}`;
                    } else {
                        // L-shape: vertical then horizontal
                        const midY = (link.y1 + link.y2) / 2;
                        d = `M${link.x1},${link.y1} L${link.x1},${midY} L${link.x2},${midY} L${link.x2},${link.y2}`;
                    }
                } else if (link.type === 'L') {
                    // Explicit L-shape with 3 points
                    d = `M${link.x1},${link.y1} L${link.x2},${link.y2} L${link.x3},${link.y3}`;
                }

                path.setAttribute('d', d);
                let linkClass = 'link';
                if (link.isRouter) {
                    linkClass += ' router';
                } else if (link.active) {
                    linkClass += ' active';
                }
                path.setAttribute('class', linkClass);
                svg.appendChild(path);
            });

            // Draw nodes
            nodes.forEach(node => {
                if (node.type === 'label') {
                    const txt = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    txt.setAttribute('x', node.x);
                    txt.setAttribute('y', node.y + 12);
                    if (node.align === 'middle') {
                        txt.setAttribute('text-anchor', 'middle');
                    }
                    txt.setAttribute('class', 'branch-text' + (node.active ? ' active' : ''));
                    txt.textContent = node.name.toUpperCase();
                    svg.appendChild(txt);
                } else {
                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', 'node-group');
                    g.onclick = () => openStepModal(currentRunId, node.step_index, currentDbPath);

                    // White rect with gray border
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', node.x);
                    rect.setAttribute('y', node.y);
                    rect.setAttribute('width', node.w);
                    rect.setAttribute('height', node.h);
                    rect.setAttribute('class', 'node-rect' + (node.isRouter ? ' router' : ''));
                    g.appendChild(rect);

                    // Status icon colors
                    const iconColors = {
                        completed: '#1a7f37',
                        running: '#0969da',
                        failed: '#cf222e',
                        skipped: '#8c959f',
                        pending: '#8c959f'
                    };
                    const iconColor = iconColors[node.status] || iconColors.pending;

                    // Status icon (CircleCI style)
                    const iconG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    const iconSize = 16;
                    const iconX = node.x + 12;
                    const iconY = node.y + (node.h - iconSize) / 2;

                    if (node.isRouter) {
                        // Router: filled diamond shape (purple for routers)
                        const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const cx = iconX + iconSize/2;
                        const cy = iconY + iconSize/2;
                        const r = iconSize/2;
                        diamond.setAttribute('d', `M${cx},${cy-r} L${cx+r},${cy} L${cx},${cy+r} L${cx-r},${cy} Z`);
                        diamond.setAttribute('fill', '#8250df');
                        diamond.setAttribute('stroke', '#8250df');
                        diamond.setAttribute('stroke-width', '2');
                        iconG.appendChild(diamond);
                    } else if (node.status === 'completed') {
                        // Green circle with white checkmark
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', iconX + iconSize/2);
                        circle.setAttribute('cy', iconY + iconSize/2);
                        circle.setAttribute('r', iconSize/2);
                        circle.setAttribute('fill', iconColor);
                        iconG.appendChild(circle);

                        const check = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        check.setAttribute('d', `M${iconX + 4},${iconY + 8} l3,3 l5,-6`);
                        check.setAttribute('fill', 'none');
                        check.setAttribute('stroke', 'white');
                        check.setAttribute('stroke-width', '2');
                        check.setAttribute('stroke-linecap', 'round');
                        check.setAttribute('stroke-linejoin', 'round');
                        iconG.appendChild(check);
                    } else if (node.status === 'running') {
                        // Blue spinning circle with animation
                        const spinnerG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        const cx = iconX + iconSize/2;
                        const cy = iconY + iconSize/2;
                        spinnerG.setAttribute('class', 'spinner');
                        spinnerG.setAttribute('style', `transform-origin: ${cx}px ${cy}px`);

                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', cx);
                        circle.setAttribute('cy', cy);
                        circle.setAttribute('r', iconSize/2 - 1);
                        circle.setAttribute('fill', 'none');
                        circle.setAttribute('stroke', iconColor);
                        circle.setAttribute('stroke-width', '2.5');
                        circle.setAttribute('stroke-dasharray', '12 8');
                        circle.setAttribute('stroke-linecap', 'round');
                        spinnerG.appendChild(circle);
                        iconG.appendChild(spinnerG);
                    } else if (node.status === 'failed') {
                        // Red circle with X
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', iconX + iconSize/2);
                        circle.setAttribute('cy', iconY + iconSize/2);
                        circle.setAttribute('r', iconSize/2);
                        circle.setAttribute('fill', iconColor);
                        iconG.appendChild(circle);

                        const x = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        x.setAttribute('d', `M${iconX + 5},${iconY + 5} l6,6 M${iconX + 11},${iconY + 5} l-6,6`);
                        x.setAttribute('stroke', 'white');
                        x.setAttribute('stroke-width', '2');
                        x.setAttribute('stroke-linecap', 'round');
                        iconG.appendChild(x);
                    } else {
                        // Gray outline circle for pending/skipped
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', iconX + iconSize/2);
                        circle.setAttribute('cy', iconY + iconSize/2);
                        circle.setAttribute('r', iconSize/2 - 1);
                        circle.setAttribute('fill', 'none');
                        circle.setAttribute('stroke', iconColor);
                        circle.setAttribute('stroke-width', '1.5');
                        iconG.appendChild(circle);
                    }
                    g.appendChild(iconG);

                    // Name (truncate if needed)
                    const nameText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    nameText.setAttribute('x', node.x + 36);
                    nameText.setAttribute('y', node.y + node.h/2 + 4);
                    nameText.setAttribute('class', 'node-text');
                    // Calculate max chars based on available space
                    const hasDuration = node.duration_s != null && !node.isRouter;
                    const availableWidth = node.w - 36 - (hasDuration ? 55 : 10);
                    const maxChars = Math.floor(availableWidth / 7.5);
                    const displayName = truncateName(node.name, maxChars);
                    nameText.textContent = displayName;
                    // Add tooltip if truncated
                    if (node.name.length > maxChars) {
                        const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
                        title.textContent = node.name;
                        nameText.appendChild(title);
                    }
                    g.appendChild(nameText);

                    // Duration
                    if (hasDuration) {
                        const dur = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        dur.setAttribute('x', node.x + node.w - 10);
                        dur.setAttribute('y', node.y + node.h/2 + 4);
                        dur.setAttribute('text-anchor', 'end');
                        dur.setAttribute('class', 'node-duration');
                        const d = node.duration_s;
                        dur.textContent = d < 1 ? Math.round(d * 1000) + 'ms' : d.toFixed(1) + 's';
                        g.appendChild(dur);
                    }

                    svg.appendChild(g);
                }
            });

            if (container) {
                container.scrollLeft = prevScrollLeft;
                container.scrollTop = prevScrollTop;
            }
        }

        function handleStepsUpdate(evt) {
            if (evt.target && evt.target.id === 'steps-data') {
                setData();
                render();
            }
        }

        // Initial
        setData();
        document.getElementById('btn-h').classList.toggle('active', layout === 'horizontal');
        document.getElementById('btn-v').classList.toggle('active', layout === 'vertical');
        render();

        document.body.addEventListener('htmx:afterSwap', handleStepsUpdate);
        window.setLayout = setLayout;
    })();
    </script>

    <!-- Step list -->
    <div class="mt-4 border-t border-gray-200 pt-4"
         id="step-list"
         hx-get="/runs/{{ run.id }}/steps/list?db={{ db_path }}"
         hx-trigger="steps:update"
         hx-swap="innerHTML">
        {% include "partials/step_list.html" %}
    </div>
</div>
{% else %}
<p class="text-gray-500">No step information available.</p>
{% endif %}
